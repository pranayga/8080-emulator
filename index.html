<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>8080-Emulator: 8080-emulator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">8080-Emulator
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">An Intel 8080 emulator for Space Invaders</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">8080-emulator </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> This repo contains worked out tutorials to learn software emulation. The main goal is to write a C based functional 8080 emulator. Post which we will move to emulation Nintendo's GameBoy in a separate Repo (or playstation maybe).</p>
<p>For now, let's get going with the tutorials on <a href="http://emulator101.com">Emulator 101</a>. </p><blockquote class="doxtable">
<p>Note: These might changes as I learn more and currently may not be the best way to go about things. <code>But really what is?</code> </p>
</blockquote>
<p><code>ls /our_future</code>:</p>
<p><img src="space_pandu.gif" alt="" class="inline" title="Sample Output window"/></p>
<h1>Emulating 8080</h1>
<p>Let's start by following the Steps on <a href="http://emulator101.com">Emulator 101</a>.</p>
<blockquote class="doxtable">
<p>Critical: Do not look at this until necessary, but here's a <a href="https://github.com/herrecito/invaders">completed version</a> I came across this tutorial. But the <b>Useful links</b> section is actually quite useful. </p>
</blockquote>
<h2>OpCode</h2>
<p>Emulator 101's Opcode is linked <a href="http://www.emulator101.com/8080-by-opcode.html">here</a>. But IMO, it gives too much away. There's always the <a href="http://www.nj7p.info/Manuals/PDFs/Intel/9800153B.pdf">8080 system manual</a>, but that might be a little too much so let's keep it aside for now. I think referring to below links would be more work and fruitful:</p><ul>
<li><a href="https://gist.github.com/joefg/634fa4a1046516d785c9">https://gist.github.com/joefg/634fa4a1046516d785c9</a></li>
<li><a href="https://pastraiser.com/cpu/i8080/i8080_opcodes.html">https://pastraiser.com/cpu/i8080/i8080_opcodes.html</a></li>
<li><a href="http://www.classiccmp.org/dunfield/r/8080.txt">http://www.classiccmp.org/dunfield/r/8080.txt</a></li>
</ul>
<p><b>To top it off</b>, this <a href="https://drakeor.com/uploads/8080-Programmers-Manual.pdf">programming manual</a> seems quite useful, and small enough for now.</p>
<p>The tutorial starts by mentioning guides such as above, then says to go find the ROM. Here's what I got:</p><ul>
<li>ROM Mirror : <a href="https://drakeor.com/uploads/invaders.zip">C code</a></li>
</ul>
<p>Next, I would recommend you to read the programming manual (91 Page one). The first 2 chapters should be enough for now. By now it would have struck you:</p><ul>
<li>The ROM contains the 8080 code we want to execute after some setup (like Input and display)</li>
<li>We want to apply identical effects to those components, which a real system would notice. Basically software emulation!</li>
</ul>
<h3>RoadMap:</h3>
<ol type="1">
<li>Emulate the basic commands of 8080, <code>write a disassembler -&gt; call C equivalents for those assembly instructions</code>.</li>
</ol>
<ol type="1">
<li>Write the IO (Graphical Interface) to actually do the GUI updates</li>
</ol>
<ol type="1">
<li>Implement Input</li>
</ol>
<ol type="1">
<li>Implement Sound driver</li>
</ol>
<blockquote class="doxtable">
<p>Note: While these are important individual steps, we'll go in a manner where we just implement enough to get started with the next step and then keep coming back for extensions. This is an important part of rapid prototype dev which I've been lacking in and is very much needed in today's world. So let's practice that! </p>
</blockquote>
<h2>Disassembling &amp; Debugging 8080</h2>
<p>Well, let's get started. We'll first do an overall instruction base like <a href="http://www.emulator101.com/disassembler-pt-1.html">disass_1</a>. Then We'll follow the <a href="http://www.emulator101.com/emulator-shell.html">order of the posts</a>, cross-referring with Chapter 4 in the system manual. At the same time, we'll be using the ROM itself to figure out which instruction to emulate next. When we run the ROM and something doesn't work, that's the instruction to figure out! Just exec the ROM unless you hit an instruction that you've not implemented yet. Implement, then keep going.</p>
<p>Below is a example of decompile mode: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="cpu__8080_8h.html#a96d804d06fba8a45c824fa24f221c607">decompile_inst</a>(<a class="code" href="structcpu__state.html">cpu_state</a>* cpu, uint16_t* next_inst){</div>
<div class="line">    uint8_t Instt = <a class="code" href="memory__8080_8h.html#adbf06f95e189e3fa3363b6c982c48228">mem_read</a>(&amp;cpu-&gt;<a class="code" href="structcpu__state.html#aa573ac9d5b2430cd7b6eb2278817cec2">mem</a>, (*next_inst));</div>
<div class="line">    cpu-&gt;<a class="code" href="structcpu__state.html#aebdb630606e8b859f66d49694c633fb1">PC</a> = (*next_inst);</div>
<div class="line"> </div>
<div class="line">    (*next_inst) += opcode_lookup[Instt].<a class="code" href="structinstt__8080__op.html#a8d0be7b06606e853a903dd0fcd0d7f4d">size</a>;</div>
<div class="line"> </div>
<div class="line">    uint16_t inital_pc_ptr = cpu-&gt;<a class="code" href="structcpu__state.html#aebdb630606e8b859f66d49694c633fb1">PC</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span>(opcode_lookup[Instt].target_func == 0x0){</div>
<div class="line">         opcode_lookup[Instt].<a class="code" href="structinstt__8080__op.html#a26c64ff08d90cce553df4576e2654b4e">target_func</a> = <a class="code" href="opcodes__8080_8h.html#a925529e074860d1da90da0bd30911f4e">UNDEFINED_OP_WRAP</a>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> ret = opcode_lookup[Instt].<a class="code" href="structinstt__8080__op.html#a26c64ff08d90cce553df4576e2654b4e">target_func</a>(cpu, inital_pc_ptr, Instt);</div>
<div class="line">    <span class="keywordflow">return</span> ret;</div>
<div class="line">}</div>
<div class="ttc" id="acpu__8080_8h_html_a96d804d06fba8a45c824fa24f221c607"><div class="ttname"><a href="cpu__8080_8h.html#a96d804d06fba8a45c824fa24f221c607">decompile_inst</a></div><div class="ttdeci">int decompile_inst(cpu_state *cpu, uint16_t *next_inst)</div><div class="ttdoc">Recompile mode.</div><div class="ttdef"><b>Definition:</b> cpu_8080.c:71</div></div>
<div class="ttc" id="amemory__8080_8h_html_adbf06f95e189e3fa3363b6c982c48228"><div class="ttname"><a href="memory__8080_8h.html#adbf06f95e189e3fa3363b6c982c48228">mem_read</a></div><div class="ttdeci">uint8_t mem_read(v_memory *mem, uint16_t offset)</div><div class="ttdoc">Lowest level memory read access abstraction. Typecasts the offset to void* + base to get the actual p...</div><div class="ttdef"><b>Definition:</b> memory_8080.c:18</div></div>
<div class="ttc" id="aopcodes__8080_8h_html_a925529e074860d1da90da0bd30911f4e"><div class="ttname"><a href="opcodes__8080_8h.html#a925529e074860d1da90da0bd30911f4e">UNDEFINED_OP_WRAP</a></div><div class="ttdeci">int UNDEFINED_OP_WRAP(UNUSED cpu_state *cpu, UNUSED uint16_t base_PC, UNUSED uint8_t op_code)</div><div class="ttdoc">Undefined OPCODE Functor.</div><div class="ttdef"><b>Definition:</b> opcodes_8080.h:252</div></div>
<div class="ttc" id="astructcpu__state_html"><div class="ttname"><a href="structcpu__state.html">cpu_state</a></div><div class="ttdoc">cpu_state: This structure keeps runtime state of all the registers in the CPU.</div><div class="ttdef"><b>Definition:</b> cpu_8080.h:64</div></div>
<div class="ttc" id="astructcpu__state_html_aa573ac9d5b2430cd7b6eb2278817cec2"><div class="ttname"><a href="structcpu__state.html#aa573ac9d5b2430cd7b6eb2278817cec2">cpu_state::mem</a></div><div class="ttdeci">v_memory mem</div><div class="ttdef"><b>Definition:</b> cpu_8080.h:103</div></div>
<div class="ttc" id="astructcpu__state_html_aebdb630606e8b859f66d49694c633fb1"><div class="ttname"><a href="structcpu__state.html#aebdb630606e8b859f66d49694c633fb1">cpu_state::PC</a></div><div class="ttdeci">uint16_t PC</div><div class="ttdef"><b>Definition:</b> cpu_8080.h:90</div></div>
<div class="ttc" id="astructinstt__8080__op_html_a26c64ff08d90cce553df4576e2654b4e"><div class="ttname"><a href="structinstt__8080__op.html#a26c64ff08d90cce553df4576e2654b4e">instt_8080_op::target_func</a></div><div class="ttdeci">OP_WRAP target_func</div><div class="ttdef"><b>Definition:</b> opcodes_8080.h:31</div></div>
<div class="ttc" id="astructinstt__8080__op_html_a8d0be7b06606e853a903dd0fcd0d7f4d"><div class="ttname"><a href="structinstt__8080__op.html#a8d0be7b06606e853a903dd0fcd0d7f4d">instt_8080_op::size</a></div><div class="ttdeci">uint8_t size</div><div class="ttdef"><b>Definition:</b> opcodes_8080.h:33</div></div>
</div><!-- fragment --><p>Once you implement all the instructions, how do you know if you've implemented the instructions correctly? Well as described in <a href="http://www.emulator101.com/finishing-the-cpu-emulator.html">finishing-cpu</a> and <a href="http://www.emulator101.com/full-8080-emulation.html">full-emulation</a>, there are two major ways:</p><ol type="1">
<li>Use <a href="https://bluishcoder.co.nz/js8080/">online emulator</a> to execute the ROM and match the trace with your offline version. This would help you point out the exact location where your execution differs. This would be useful for detecting in-depth bugs that cannot be detected by instruction level tests. However, you could have multiple broken instructions, making it harder to zero into the cause.</li>
<li>Use <a href="http://www.emulator101.com/files/cpudiag.asm">Debug ROM</a> which executes each instruction and checks if it has the expected behavior. This should help you detect the majority of the issues. A couple of things to note:<ul>
<li>This ROM expects to start at 0x100 ROM ADDR</li>
<li>Due to some funky issue, you might have to tweak the start point of the SP to a custom value to prevent it from corrupting the ROM.</li>
<li>These minor details have been listed in the article above. Do refer.</li>
</ul>
</li>
</ol>
<h2>Interrupts</h2>
<p>At this point, let's assume we have a fully functioning emulator. Well, do we? Currently, our code runs at full speed, trying to get the instructions executed as fast as possible. This historically hasn't been the <a href="https://en.wikipedia.org/wiki/Turbo_button">best for games</a>. If you run your code right now, you'll notice that it's stuck in a loop <code>WaitOnDelay</code>. It would be helpful to look at <a href="http://www.computerarcheology.com/Arcade/SpaceInvaders/Code.html">reverse engineering of the code</a>, and probably you'll be waiting for the <code>isrDelay</code> variable. But what is that anyway?</p>
<p><b>Timing in Space Invaders</b>: So the question to ask here would be: </p><blockquote class="doxtable">
<p>Who in the world updates this memory location? </p>
</blockquote>
<p>I would encourage you to look at the code and find out the answer. Try <code>Ctrl+F</code> for <code>isrDelay</code>, or <code>&amp;isrDelay</code>.</p>
<p>Okay, space invaders makes use of an <code>external Interrupt</code> to do the timing. Via the experiment above, you would have noticed that the memory location <code>20C0 isrDelay</code>, is updated at <code>address: 0019</code> which is part of <code>ScanLine224</code>. Now would be a great time to read the <a href="http://www.computerarcheology.com/Arcade/SpaceInvaders/Hardware.html">hardware configuration of SpaceInvaders</a>, since it will be very relevant now.</p>
<p>You see, there's an external interrupt every 1/2 frame point, where the frame rate is 60Hz. This basically is a clock that triggers the <code>RST</code> command by setting the condition flag. Here's a <a href="https://github.com/pranayga/8080-emulator/blob/19d87319b66cdb6b9b8c6cb387a3955eabbdc1c3/src/space.c#L252-L263">snippet of the main code</a> doing it.</p>
<p>Don't worry about the SDL_USEREVENT stuff. It's just a way to create user-generated events using a timer. Exec loop <a href="https://github.com/pranayga/8080-emulator/blob/19d87319b66cdb6b9b8c6cb387a3955eabbdc1c3/src/cpu_8080.c#L46-L50">consuming the <code>interrupt flag</code></a>. This enables us to implement a CPU unbound timer!</p>
<p>Now you shouldn't be stuck in the loop anymore. Okay at this point, we have the major things in place. Some visual output would be nice. Let's have a look.</p>
<h2>SDL2 GUI</h2>
<p>For GUI, I used SDL2. Mainly because it has a C API and integrates nicely with our existing code. You might want to the following tutorials which might prove to be handy:</p><ul>
<li><a href="https://www.youtube.com/watch?v=yFLa3ln16w0">General SDL Concepts</a> - A good intro to core concepts of SDL2</li>
<li><a href="https://wiki.libsdl.org/SDL_AddTimer">Creating Custom Timer Event</a> - This should help you generate the interrupts as 60Hz</li>
<li><a href="https://benedicthenshaw.com/soft_render_sdl2.html">Direct Access to Window's Surface</a> - Should help you with a way to directly access pixels for a window</li>
<li><a href="https://gigi.nullneuron.net/gigilabs/handling-keyboard-and-mouse-events-in-sdl2/">Key Stroke events</a> - Should Help you with the Keypress detection and event handling</li>
</ul>
<p>Few points of advice:</p><ul>
<li>You will notice in the game docs that the memory that the game logic draws to is rotated by 90* clockwise. Hence, you will have to rotate it back to the upright location and then write to the game window's backing store</li>
<li>You might want to read the <code>PORT IO</code> section too, after which it will make more sense.</li>
</ul>
<h2>PORT IO</h2>
<h3>Dedicated Shift Hardware</h3>
<p>While working on the SDL2 GUI, you'll realize that to draw properly and efficiently, the game logic makes use of shift registers. But hold on a minute pandu, there are no registers in Intel 8080! You're right, that's why on out the <code>PORT</code> IO is used for that purpose. You can find more information <a href="http://www.computerarcheology.com/Arcade/SpaceInvaders/Hardware.html">here</a>.</p>
<h3>Other IO</h3>
<p>Other than those clever <code>shift registers</code>, the rest should be good to implement. you might wanna hotwire the <code>IN</code> and <code>OUT</code> instructions to custom versions that support the behavior specified <a href="http://www.computerarcheology.com/Arcade/SpaceInvaders/Hardware.html">here</a>.</p>
<p>Feel free to look through the code if you want to look at a not so simple but interesting way of implementing it using <code>functors</code>. I intended to keep the code generic while supporting this idea. I think it's pretty neat. Setting <code>IN/OUT</code> backing stores correctly should allow your game to read keypresses and produce sound.</p>
<h1>Setup</h1>
<p>In order to run the code on your ubuntu box:</p><ul>
<li>Clone the repo</li>
<li><code>make install</code> - Install the packages required</li>
<li><code>make extractROM</code> - Unzip the ROM</li>
<li><code>make DEBUG=0 DECOMPILE=0</code> - Run the Emulator</li>
</ul>
<h1>Emulation Bookmarks &amp; Thanks</h1>
<ul>
<li><a href="http://www.emulator101.com/">Emulator 101 - Welcome</a></li>
<li><a href="http://fms.komkon.org/EMUL8/HOWTO.html">HOWTO: Writing a Computer Emulator</a></li>
<li><a href="https://blog.scottlogic.com/2017/12/13/chip8-emulator-webassembly-rust.html">Writing a CHIP-8 emulator with Rust and WebAssembly</a></li>
<li><a href="https://www.codemotion.com/magazine/dev-hub/gamedev/how-to-build-an-emulator/">How to build an emulator - Codemotion Magazine</a></li>
<li><a href="https://github.com/LemonBoy/Space-Invaders-Emulator">LemonBoy/Space-Invaders-Emulator: Fuck PS3 we haz Space Invaders!</a></li>
</ul>
<ol type="1">
<li>JS<ul>
<li><a href="https://www.freecodecamp.org/news/creating-your-very-own-chip-8-emulator/">How to Create Your Very Own Chip-8 Emulator</a></li>
<li><a href="http://imrannazar.com/GameBoy-Emulation-in-JavaScript:-Timers">Imran Nazar: GameBoy Emulation in JavaScript: Timers</a></li>
</ul>
</li>
</ol>
<ol type="1">
<li>C++<ul>
<li><a href="http://www.multigesture.net/articles/how-to-write-an-emulator-chip-8-interpreter/">How to write an emulator (CHIP-8 interpreter) — Multigesture.net</a></li>
</ul>
</li>
</ol>
<ol type="1">
<li>GameBoy<ul>
<li><a href="https://ia803208.us.archive.org/9/items/GameBoyProgManVer1.1/GameBoyProgManVer1.1.pdf">GameBoyProgManVer1.1.pdf</a></li>
<li><a href="https://cturt.github.io/cinoop.html">Cinoop</a> 1.NES</li>
<li><a href="http://wiki.nesdev.com/w/index.php/Programming_guide">Programming guide - Nesdev wiki</a></li>
<li><a href="http://nesdev.com/NES%20emulator%20development%20guide.txt">nesdev.com/NES emulator development guide.txt</a></li>
<li><a href="https://hackaday.com/2012/10/12/emulators-101-how-to-write-a-program-that-functions-like-an-nes-cpu/">Emulators 101: How To Write A Program That Functions Like An NES CPU | Hackaday</a></li>
<li><a href="https://yizhang82.dev/nes-emu-overview">Writing your own NES emulator - overview | yizhang82’s blog</a></li>
</ul>
</li>
</ol>
<ol type="1">
<li>SDL C<ul>
<li><a href="https://lazyfoo.net/tutorials/SDL/index.php#Hello%20SDL">Lazy Foo' Productions - Beginning Game Programming v2.0</a></li>
<li><a href="https://stephenmeier.net/2014/08/10/sdl-2-0-tutorial-00-the-basic-sturcture/">SDL 2.0 Tutorial-00: The Basic Sturcture | Stephen Meier</a> </li>
</ul>
</li>
</ol>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.0
</small></address>
</body>
</html>
